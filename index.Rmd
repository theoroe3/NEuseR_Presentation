---
title: "The Trouble with Tibbles"
subtitle: "Theo Roe"
author: '`r jrPresentation::get_author()`'
output:
  xaringan::moon_reader:
    css: ["default", "style.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, message=FALSE}
options(htmltools.dir.version = FALSE)
library("jrPresentation")
library(dplyr)
set_presentation_options()
```


layout: true
`r add_border(inverse=FALSE)`
---

# What are tibbles ?  

  * Tibbles are a modern take on data frames
  
  * _"keeping what time has proven to be effective, and throwing out what is not"_
  <!-- r is an old language, changing base code would ultimately lead to many problems -->
  * Part of the core tidyverse 
  
  * Tibbles are a unifying feature of the tidyverse
  
```{r eval = FALSE}
install.packages("tidyverse")
library(tidyverse)
```
 
  * Tibbles force you to confront problems earlier, typically leading to cleaner, more expressive code
  
  * Chat more about this later 
---
background-image: url(assets/tibbles.jpg)
# the trouble with tibbles...
---
layout: true
`r add_border(inverse=FALSE)`
 
---

# Come on then! Show me a tibble

 Tibbles can be created three ways:
  
.pull-left[
  1) Using `tibble()`
```{r}
tibble(a = 1:26,
              b = letters)  
```  
]
.pull-right[
  2) By coercion  
```{r}
df = data.frame(a = 1:26, 
                b = letters)
as_tibble(df)
```
]


---

# Come on then! Show me a tibble

3) Using `tribble()` <!-- short for transposed tribble -->

* `tribble()` is a way of laying out small amounts of data in easy to read form 

```{r}
tribble(
  ~a, ~`+`, ~c,
  #--|----|----
  "T",   1, 3.6,
  "h",   2, 8.5,
  "e",   3, 8.5,
  "0",   4, 8.5)
```
<!-- column headers are layed out as formulas i.e ~x -->



---

layout: true
`r add_border(inverse=FALSE)`

---

# tibbles Vs. data frames

* It's possible for a tibble to have column names that are not valid R variable names, aka non-syntactic names
.pull-left[
```{r}
tibble(
  `->` = "arrow", 
  ` ` = "space",
  `7` = "number"
)
```
]

.pull-right[
```{r}
 data.frame(
   "->" = "colon", 
   ` ` = "space",
   `7` = "number"
 )
```
 ]



---
```{r include = FALSE}
options(tibble.print_max = 20, tibble.print_min = 10)
```

# tibbles Vs. data frames

* A refined print process means a tibble will only show the first
 10 rows and as many columns can fit on your screen:
.pull-left[
```{r}
 tibble(a = 1:26,
               b = letters)
```
]
.pull-right[
```{r}
head(data.frame(a = 1:26,
              b = letters))
```
]

---

# tibbles Vs. data frames

* the preset row options be changed using
```{r, eval = TRUE}
 options(tibble.print_max = 3, tibble.print_min = 1)
```
 i.e. if there is more than 3 rows, print only 1 rows
 <!--  default is 20, 10-->
.pull-left[
```{r}
options(tibble.print_max = 3, 
        tibble.print_min = 1)
tibble(1:3)  
```
]
.pull-right[
```{r}
options(tibble.print_max = 3, 
        tibble.print_min = 1)
tibble(1:4)
```
]

 More options are available, find them by using `package?tibble`

---

# tibbles Vs. data frames: subsetting

* Tibbles don't drop the variable type or partial match, no more strings as factors!  

.pull-left[
```{r}
tib = tibble(aa = 1:4,
         bb = letters[1:4])
tib[[2]]
tib$a
tib$aa
tib[["bb"]]
class(tib[[2]])
```
]
.pull-right[
```{r}
df = data.frame(aa = 1:4,
            bb = letters[1:4])
df[[2]]
df$a
class(df[[2]])
```
 ]